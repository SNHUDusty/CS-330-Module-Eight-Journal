# CS-330-Module-Eight-Journal

How do I approach designing software?

    My approach to software design begins with breaking down the project into clear, achievable goals and identifying its core functional components. I analyze the software's objectives, then outline the necessary structures, classes, and their relationships. From the outset, I prioritize scalability and modularity to facilitate future updates. With a solid foundation in place, I plan the flow of data and logic between components, ensuring the final design is functional, transparent, and efficient.

What new design skills has your work on the project helped you to craft?

    This project enhanced my spatial reasoning and scene organization skills in 3D environment design. I learned to plan object placement using coordinate systems and to structure visual components modularly. I also gained valuable experience integrating artistic and technical design—balancing the visual appeal of textures and lighting with the logical structure in the supporting code.

What design process did you follow for your project work?

    My design process followed an iterative, modular approach. I started by identifying the main elements of the scene: the football field, the football, and the cones. Each of these elements was created using basic geometric shapes. Once the primary components were established, I added visual complexity through textures and lighting. At each stage, I tested how well the components integrated, ensuring that the camera, lighting, and objects collaborated effectively. Finally, I refined the details, such as navigation speed, texture scaling, and light placement.

How could tactics from your design approach be applied in future work?

    The modular and iterative methods I employed can be applied to nearly any software or game development project. By building each feature independently and testing it in isolation before integration, I can avoid large-scale errors. Additionally, planning with scalability in mind ensures that future features or visual elements can be added without significant refactoring. This structured workflow will be beneficial in both professional software engineering and interactive design projects.

How do I approach developing programs?

    I approach program development by establishing a clear architecture that separates logic, rendering, and user input. I then develop in small, testable increments, beginning with foundational systems before progressing to more advanced features. Throughout the process, I prioritize consistent testing and debugging to ensure stability and correctness before adding new layers of complexity.

What new development strategies did you use while working on your 3D scene?

    While working on my 3D scene, I learned to use modular class structures, such as SceneManager, ShaderManager, and ViewManager, to organize my code efficiently. I also implemented reusable functions for transformations, lighting, and rendering, improving code readability and reducing redundancy. Another key strategy was utilizing real-time feedback loops by running the program frequently to test camera movement, lighting angles, and texture mapping as I built the scene.

How did iteration factor into your development?

    Iteration was crucial in my development process. Each milestone served as a checkpoint, allowing me to refine my earlier work based on new insights and feedback. For instance, I initially built simple shapes, then enhanced them with textures, and subsequently added lighting and camera control. This staged approach to iteration helped me identify performance issues, improve visual quality, and ensure that each component integrated smoothly before finalizing the project.

How has your approach to developing code evolved throughout the milestones, which led you to the project’s completion?

    My approach evolved from focusing solely on completing tasks functionally to building systems that are both efficient and maintainable. Early in the course, I wrote procedural code to achieve quick results, but as I progressed, I adopted a more object-oriented, modular approach. By the time I completed the final project, I was writing reusable, well-commented code that adhered to best practices and reflected a deeper understanding of performance optimization and scene management.

How can computer science help me in reaching my goals?

    Computer science provides me with problem-solving skills and technical knowledge that directly support my career goals in software and game development. It enables me to think logically, design efficient solutions, and understand how systems interact. Additionally, the discipline fosters a commitment to lifelong learning, which is essential in a field that continuously evolves with new technology.

How do computational graphics and visualizations give you new knowledge and skills that can be applied in your future educational pathway?

    Computational graphics and visualizations have enhanced my understanding of mathematical modeling, spatial logic, and the use of APIs such as OpenGL. These skills will support my future studies in advanced computer science courses, particularly those related to simulation, artificial intelligence, and interactive design. Additionally, they have deepened my appreciation for the connection between data and visuals, which will be valuable for future coursework focused on data visualization or UI/UX design.

How do computational graphics and visualizations give you new knowledge and skills that can be applied in your future professional pathway?

    Professionally, the skills I gained from this course—such as 3D modeling, lighting simulation, and interactive camera control—are directly applicable to game development, simulation design, and visualization work. My understanding of how to optimize rendering and manage real-time scenes prepares me for roles in both software development and creative technology fields. These competencies also open doors to industries like engineering, entertainment, and education, where computational visualization is becoming increasingly essential.
